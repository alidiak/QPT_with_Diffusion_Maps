function MHchain = MetropolisHastings(chain_size,evals, varargin) 
% s0, mps_psi, a,b,w)
%   MetropolisHastingsAlgorithm will construct a Markov Chain of size
%   chain_size using the Metropolis acceptance function. The evals that the 
%   individual states can take on as well as either the 'lattice size' N 
%   or an initial state must be input as well as the network parameters.
%   Not entering a,b,w and entering mps_psi instead will make the function 
%   use the mps based calculation of the wavefunction. 
%
%   The next state s1 will be generated by randomly changing one eval in
%   the list s0 and will be accepted according to the Metropolis acceptance
%   function. burn_in is an optional boolean input that will cut off the 
%   beginning of the Markov Chain if true. This should help the chain
%   better approximate the true probability distribution as it may take a
%   number of steps to get away from a region of low-density if that is
%   where the inital condition was. 

%% Making s0, the initial state if not input.

while ~isempty(varargin)
    switch lower(varargin{1})
        
        case 's0' 
            s0=varargin{2}; % initial config
        case 'mps_psi'
            mps_psi=varargin{2}; % for MPS
        case 'psi'
            psi=varargin{2}; % for ED
        case 'a'
            a=varargin{2}; % a,b,w for RBM
        case 'w' 
            w=varargin{2};
        case 'b'
            b=varargin{2}; 
        case 'angle'
            angle=varargin{2}; % generalizing flips to rotations
        otherwise
            error(['Invalid Input: ' varargin{1}])        
    end
    varargin(1:2)=[];
end

if exist('s0','var')
    N=length(s0);
else
    if exist('w','var')
        N=min(size(w));
    elseif exist('mps_psi','var')
        N=max(size(mps_psi));
    elseif exist('psi','var')
        N=size(psi{2},2);
    end
    s0 =zeros(N,1);
    for n=1:N
        % chooses a random number in evals for the nth site in s0
        pos = randi(length(evals));
        s0(n) = evals(pos);
    end
end

%% Generating a Markov Chain with the Metropolis Hastings Algorithm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% initialize the chain. Each row will contain an iteration. 
MHchain = zeros(chain_size, N);

% initializing the first value in the chain.
MHchain(1,:) = s0;

for n = 1:(chain_size-1)
         
    % The random position that will be altered
    pos = randi(N,1);
        
    % Constructing the potentially next state in the chain
    alt_state = MHchain(n,:);
    
    % flips/rotates the eval at random position. For rotation, equal/half
    % chance that it will rotate one way or the other.
    if exist('angle','var')
        if rand>=0.5
            alt_state(pos) = exp(1i*angle)*alt_state(pos); %forward rot
        else
            alt_state(pos) = exp(-1i*angle)*alt_state(pos); %backwards rot
        end
    else
        alt_state(pos) = -1*alt_state(pos);
    end
    
    %probability of new state divided by old.
    if exist('w','var') && exist('a','var') && exist('b','var') % method for RBM
        prob=((conj(ppsi(a,b,w,alt_state)))*ppsi(a,b,w,alt_state))/...
        ((conj(ppsi(a,b,w,MHchain(n,:))))*ppsi(a,b,w,MHchain(n,:)));
    elseif exist('mps_psi','var') % method for MPS
        prob=((conj(MPS_psi(mps_psi,alt_state,evals))).*MPS_psi(mps_psi,alt_state,evals)/...
        ((conj(MPS_psi(mps_psi,MHchain(n,:),evals))).*MPS_psi(mps_psi,MHchain(n,:),evals)));
    elseif exist('psi','var') %method for exact diagonalization
%         if (isreal(psi{2}) && isreal(alt_state))
%         [q,idx_alt]=ismember(alt_state,psi{2},'rows');
%         [q,idx]=ismember(MHchain(n,:),psi{2},'rows');  
     % permutations, Z, should be input as the second cell in psi. Identifies 
     % which psi coef to use. Below is generalization for complex input.
        %else
        [q,im_idx_alt]=ismembertol(imag(alt_state),imag(psi{2}),'ByRows',true,'OutputAllIndices', true);
        [q,im_idx]=ismembertol(imag(MHchain(n,:)),imag(psi{2}),'ByRows',true,'OutputAllIndices', true);
        [q,re_idx_alt]=ismembertol(real(alt_state),real(psi{2}),'ByRows',true,'OutputAllIndices', true);
        [q,re_idx]=ismembertol(real(MHchain(n,:)),real(psi{2}),'ByRows',true,'OutputAllIndices', true);
%         if im_idx_alt{:}~=0 %weird glitch when input is mainly real, 
%      % still works, checked here that the indices are the same anyway.
%             fprintf('im_ind \n')
%             im_idx_alt{:}
%             fprintf('re_ind')
%             re_idx_alt{:}
%         end
        if ~im_idx_alt{:} %catches if and when these are empty/0
            idx_alt=re_idx_alt{:};
        elseif ~re_idx_alt{:}
            idx_alt=im_idx_alt{:};
        else
            if max(size(re_idx_alt{:}))>max(size(im_idx_alt{:})) ...
                    || max(size(re_idx_alt{:}))==max(size(im_idx_alt{:}))
                for ii=1:max(size(im_idx_alt{:}))
                    binarr=im_idx_alt{:}(ii)==re_idx_alt{:};
                    if sum(binarr)==1
                        idx_alt=binarr'*re_idx_alt{:};
                        break
                    end
                end
            else
                for ii=1:max(size(re_idx_alt{:}))
                    binarr=re_idx_alt{:}(ii)==im_idx_alt{:};
                    if sum(binarr)==1
                        idx_alt=binarr'*im_idx_alt{:};
                        break
                    end
                end
            end
        end
        if ~im_idx{:} 
            idx=re_idx{:};
        elseif ~re_idx{:}
            idx=im_idx{:};
        else
            if max(size(re_idx{:}))>max(size(im_idx{:})) ||...
                    max(size(im_idx{:}))==max(size(re_idx{:}))
                for ii=1:max(size(im_idx{:}))
                    binarr=im_idx{:}(ii)==re_idx{:};
                    if sum(binarr)==1
                        idx=binarr'*re_idx{:};
                        break
                    end
                end
            else
                for ii=1:max(size(re_idx{:}))
                    binarr=re_idx{:}(ii)==im_idx{:};
                    if sum(binarr)==1
                        idx=binarr'*im_idx{:};
                        break
                    end
                end
            end
        end
        
        %end

        prob=(conj(psi{1}(idx_alt))*psi{1}(idx_alt))/(conj(psi{1}(idx))*psi{1}(idx));        
    end
    % Metropolis Acceptance Formula
    A = min(1, prob);
           
    if A ==1 %if new state is more probable
       MHchain(n+1,:) = alt_state;
    else
       % Probability check to see if the new state will be accepted
       alpha = rand();
       if alpha<A
          MHchain(n+1,:) = alt_state;
       else
          MHchain(n+1,:) = MHchain(n,:);
       end
    end  
       
end
